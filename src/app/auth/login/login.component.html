describe('useGetOnboardingAndEdocsDetails', () => {
  // Keep existing test setup...

  it('should handle successful query completion and update app state', async () => {
    // Mock the features to ensure query runs
    (useFeaturesConfig as jest.Mock).mockReturnValue(true);
    (useBrowserDetect as jest.Mock).mockReturnValue({ isMobileApp: false });
    (getActivePolicyStatus as jest.Mock).mockReturnValue(['ACTIVE']);

    // Create mock response data
    const mockResponse = {
      getOnboardingAndEdocsStatus: {
        showOnboarding: true,
        showEdocs: false,
        policies: ['policy1', 'policy2'],
        onboardingType: 'test'
      }
    };

    // Set up mock for useApiQuery
    mockUseApiQuery.mockImplementation((query, mapper, options) => {
      // Immediately call onCompleted with mock data
      if (options.onCompleted) {
        options.onCompleted(mockResponse);
      }
      return [
        jest.fn(),
        {
          data: mockResponse,
          loading: false
        }
      ];
    });

    const mockSetAppState = jest.fn();

    // Render the hook
    renderHook(() => useGetOnboardingAndEdocsDetails(mockSetAppState), {
      wrapper: createWrapper()
    });

    // Verify setAppState was called correctly
    expect(mockSetAppState).toHaveBeenCalled();

    // Get the first callback passed to setAppState
    const updateStateCallback = mockSetAppState.mock.calls.find(
      call => call[0].toString().includes('onboardingAndEdocsResult')
    )[0];

    // Execute the callback with a previous state
    const prevState = {};
    const newState = updateStateCallback(prevState);

    // Verify the state was updated correctly
    expect(newState).toEqual({
      ...prevState,
      onboardingAndEdocsResult: {
        showOnboarding: true,
        showEdocs: false,
        onboardingType: 'test'
        // policies should be omitted
      }
    });

    // Verify the policies field was omitted
    expect(newState.onboardingAndEdocsResult).not.toHaveProperty('policies');
  });
});
